<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 葱丝瓣酱]]></title>
  <link href="http://xiaocong.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://xiaocong.github.io/"/>
  <updated>2013-06-22T16:03:23+08:00</updated>
  <id>http://xiaocong.github.io/</id>
  <author>
    <name><![CDATA[Xiaocong He]]></name>
    <email><![CDATA[xiaocong@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Yeoman: 一个新的 javascript 构建工具]]></title>
    <link href="http://xiaocong.github.io/blog/2012/10/16/yeoman-a-new-javascript-build-tool/"/>
    <updated>2012-10-16T12:59:00+08:00</updated>
    <id>http://xiaocong.github.io/blog/2012/10/16/yeoman-a-new-javascript-build-tool</id>
    <content type="html"><![CDATA[<p><a href="http://gruntjs.com/" title="Grunt is a task-based command line build tool for JavaScript projects.">Grunt</a> 是一个非常优秀的 Javascript 构建工具, 虽然它的 Build-in 的任务非常有限, 但是它提供了一套非常灵活的插件机制, 可以进行任务扩展. 目前在官网上的第三方任务插件数目已经达到 160+, 并且在持续增长中&hellip; 对于通用的功能基本上都能找到对应的任务插件, 当然你也可以自己写扩展任务来满足特殊的构建需求.</p>

<p>我通常会直接使用 <a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a>, 因为 <a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a> 已经收集齐了我想用到的任务插件, 非常顺手.</p>

<p>对我而言 <a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a> 已经足够用了, 尽管这样, 在第一次尝试 <a href="http://yeoman.io/" title="Yeoman is a robust and opinionated set of tools, libraries, and a workflow that can help developers quickly build beautiful, compelling web apps.">Yeoman</a> 之后, 我还是忍不住想向大家推荐这个新的工具.</p>

<p><blockquote><p>Yeoman is a robust and opinionated client-side stack, comprised of tools and frameworks that can help developers quickly build beautiful web applications. We take care of providing everything needed to get started without any of the normal headaches associated with a manual setup.<br/>With a modular architecture that can scale out of the box, we leverage the success and lessons learned from several open-source communities to ensure the stack developers use is as intelligent as possible.<br/>As firm believers in good documentation and well thought out build processes, Yeoman includes support for linting, testing, minification and much more, so developers can focus on solutions rather than worrying about the little things.<br/>Yeoman is fast, performant and is optimized to work best in modern browsers.</p><footer><strong>Yeoman Community <a href="http://yeoman.io/whyyeoman.html">http://yeoman.io/whyyeoman.html</a> WHY YEOMAN?</strong></footer></blockquote></p>

<p>想对比其他 Javascript 构建工具, Yeoman 具有下面非常吸引人的特点:</p>

<h2>根据定制模板快速生成程序框架</h2>

<p><a href="http://yeoman.io/" title="Yeoman is a robust and opinionated set of tools, libraries, and a workflow that can help developers quickly build beautiful, compelling web apps.">Yeoman</a> 能根据你选择的框架初始化生成程序框架, 目前已经支持大量的程序模板, 看趋势似乎是想把所有框架的初始化模板都包含进去:</p>

<pre><code>Yeoman:
  generator
  controller

Angular:
  angular:service
  angular:all
  angular:directive
  angular:view
  angular:route
  angular:filter
  angular:controller
  angular:app

Testacular:
  testacular:app

Quickstart:
  quickstart:all

Bbb:
  bbb:all

Ember:
  ember:controller
  ember:all
  ember:view
  ember:model
  ember:app

Chromeapp:
  chromeapp:all

Ember-starter:
  ember-starter:all

Backbone:
  backbone:model
  backbone:view
  backbone:router
  backbone:collection
  backbone:app
  backbone:all
</code></pre>

<p>虽然目前我只用到了 Bbb 模板, 但还是得赞一下其模板的齐全.</p>

<!--more-->


<h2>前端 Javascript 包管理</h2>

<p>在目前, 我们都是手工增加和管理前端应用中用到的 Javascript 库, 例如说 jQuery, 每次当 jQuery 发布一个新版本, 我们都不得不手工地从官网上下载最新的发布文件, 然后将这个文件复制到自己的项目中.</p>

<p>Yemoman 可以让我们省掉这种麻烦的手工操作. 它集成了前端 Javascript 包管理应用 <a href="https://github.com/twitter/bower">Bower</a>, 我们只需要简单地运行 <code>yeoman install jquery</code>, 或者 <code>yeoman update jquery</code> 就能安装或者更新 jQuery 库文件.</p>

<h2>监测文件更新并自动重新加载应用</h2>

<p>每次当源文件有了修改, 无论是 HTML, CSS, Markdown 文件, 还是脚本文件, 或者其他需要预处理的 CoffeeScript, Sass 等文件, Yeoman 带来的活动加载监测进程会自动重新加载你的页面.
在调试的过程中, 这个功能的确能帮你省不少手工刷新的麻烦:&ndash;).</p>

<p>使用 <code>yeoman server</code> 就能运行一个本地 Web 服务器, 监测文件的变化并实时重新加载应用.</p>

<h2>强大的构建系统</h2>

<p>Yeoman 也是基于 <a href="http://gruntjs.com/" title="Grunt is a task-based command line build tool for JavaScript projects.">grunt</a>, 并且额外开发了一些高度定制的构建任务. 对我来说比较新鲜的构建任务是图片的优化, 使用 OptiPNG 和 JPEGTran 优化图片来减少图片的下载时间, 初步测试的结果是能减少大约 30% 图片大小, 这在以前的项目中还没尝试过.</p>

<hr />

<p>最后, 下面是使用 Yeoman 重构后的地址本应用的<a href="/examples/yeoman-contacts/dist/">演示</a>和<a href="https://github.com/xiaocong/xiaocong.github.com/tree/source/source/examples/yeoman-contacts">源码</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发SPA前端项目必须掌握什么知识?]]></title>
    <link href="http://xiaocong.github.io/blog/2012/08/09/what-you-should-know-for-spa-project/"/>
    <updated>2012-08-09T21:46:00+08:00</updated>
    <id>http://xiaocong.github.io/blog/2012/08/09/what-you-should-know-for-spa-project</id>
    <content type="html"><![CDATA[<p>这个题目有点大, 因为对于开发SPA(单页面应用, Single Page Application), 一个前端工程师需要掌握太多太多知识和工具了.
这里只说我自己最近半年在摸索和研究前端SPA相关技术的过程中的一些经验和总结.</p>

<h2>选择合适的开发IDE</h2>

<p>一个好的IDE可以让你敲键盘的次数大大减少, 我个人推荐使用<a href="http://www.sublimetext.com/">Sublime Text</a>, 速递快, 功能强大, 可扩充, 这也是我目前正在使用的IDE.</p>

<h2>选择合适的开发语言</h2>

<p>呃, 难道还有别的选择? 开发前端应用不都是用Javascript么? 对的, 因为现在有了<a href="http://coffeescript.org/">CoffeeScript</a>.
相比于Javascript的类C++/Java静态语言语法, CoffeeScript提供了更贴近自然语言的动态语言语法, 更少的代码, 更少的语法漏洞, 更好的代码可读性.</p>

<h2>选择合适的Javascript前端MVC框架</h2>

<p>Javascript程序很难调试, 特别是当代码行数超过一定量级之后.
为了让程序逻辑更有条例, 与服务器端的web框架类似, 前端也有很多Javascript库或者框架提供了MVC或类MVC架构.
按照MVC架构进行设计, 可以很清晰地将Module(数据模块), View(页面展示), Controller(用户行为响应控制)进行分离.
对于小型web应用来说, 这可能无关紧要, 甚至MVC带来的弊端会掩盖它的优点, 但对于一个超过上千行的web应用来说,
一个清晰的程序架构可以极大地减少模块间的耦合性.</p>

<p>大家可以仔细看一下<a href="http://codebrief.com/2012/01/the-top-10-javascript-mvc-frameworks-reviewed/">Top 10 Javascript MVC框架的对比</a>.
我个人感觉, <a href="http://documentcloud.github.com/backbone/">Backbone</a>的代码更紧凑一些, 开发社区也比较活跃.</p>

<h2>模块定义与加载管理</h2>

<p>Javascript语言自身不提供代码的加载管理, 当JavaScript代码分成多个模块, 处于不同文件中时,
如何管理模块之间的依赖关系以及文件的加载顺序, 就会变成一个非常棘手的事情. 并且JavaScript自身不提供名字空间的管理, 不同模块,
不同的JavaScript库之间的都有可能出现命名冲突.</p>

<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD(Asynchronous Module Definition)</a>是用来规范如何定义模块及其依赖项, 以及如何异步加载模块.
大家可以参考<a href="http://twitter.com/addyosmani">Addy Osmani</a>的博文<a href="http://addyosmani.com/writing-modular-js/">Writing Modular JavaScript With AMD, CommonJS &amp; ES Harmony</a>来了解具体的细节.</p>

<p>目前前端使用最广泛的前端AMD库应当是<a href="http://requirejs.org/">RequireJS</a>.</p>

<h2>代码质量静态检查</h2>

<p>Javascript代码的书写格式非常自由, 甚至带着错都能运行下去, 这也是为什么JavaScript代码很难调试的原因之一.</p>

<p>进行代码质量的静态检查可以极大减少由于语法漏洞或者拼写疏忽带来的这些额外错误, 推荐使用<a href="http://www.jshint.com/">jshint</a>.
如果使用CoffeeScript, 这步可以省略了, CoffeeScript编译后的代码都能通过jshint的检测.</p>

<!--more-->


<h2>单元测试</h2>

<p>单元测试是一个非常大的话题, 我没有办法用简短的一段话或者一篇文章将单元测试涉及到的方法和工具都介绍清楚.</p>

<p>技术大牛们都不愿意做单元测试, 当然, 很少有软件工程师愿意承认自己不是技术大牛:).
因为人员, 时间或者其他各种因素, 很多软件工程师们都愿意首先舍弃单元测试, 去保证功能的实现.</p>

<p>这里我不想挑起争论, 但我的经验的确是, 从个人角度上看, 单元测试能很大加深程序员对代码的理解程度, 加速个人能力的提升;
从项目角度上看, 技术经理需要权衡当前的开发, 回归测试和后继的代码维护成本之间的平衡, 然后决定是否实施单元测试,
以及多少程度的单元测试, 这是技术经理的职责.</p>

<p>在前端web应用中比较常用的单元测试框架包括：</p>

<ul>
<li><a href="http://pivotal.github.com/jasmine/">Jasmine</a></li>
<li><a href="http://docs.jquery.com/QUnit">QUnit</a></li>
<li><a href="http://visionmedia.github.com/mocha/">Mocha</a></li>
</ul>


<p>Mock库可以采用<a href="http://sinonjs.org/">SinonJS</a>. 如果愿意, 还可以采用<a href="http://github.com/visionmedia/should.js">Should</a>,
<a href="https://github.com/LearnBoost/expect.js">Expect</a>, <a href="http://chaijs.com/">Chai</a>等Assertion库.</p>

<p>另外, 如果希望在持续集成中加入对测试的支持, 还需要加入Non-GUI浏览器的支持, 目前采用比较多的方案是:</p>

<ul>
<li><a href="http://phantomjs.org/">PhantomJS</a></li>
<li><a href="http://zombie.labnotes.org/">Zombie</a></li>
</ul>


<p>由于<a href="http://zombie.labnotes.org/">Zombie</a>当前的版本还不能支持<a href="http://requirejs.org/">RequireJS</a>, 因此我更倾向于使用<a href="http://phantomjs.org/">PhantomJS</a>.</p>

<h2>Minification &amp; Concatenation</h2>

<p>为了提高web应用的加载速度, 必须对Javascript文件, CSS文件进行Minification和Concatenation, 根据经验, 优化后的代码加载速度比优化前的要提高数倍.</p>

<p>常用的工具包括:</p>

<ul>
<li><a href="http://developer.yahoo.com/yui/compressor/">YUI Compressor</a></li>
<li><a href="http://code.google.com/closure/compiler/">Google Closure Compiler</a></li>
<li><a href="https://github.com/mishoo/UglifyJS/">UglifyJS</a></li>
</ul>


<p>大部分开源的JavaScript构建工具都集成了对这些工具的支持, 因此没必要在这些工具上面花太多精力.
使用了<a href="http://requirejs.org/">RequireJS</a>的应用, 可以直接使用其自带的<a href="http://requirejs.org/docs/optimization.html">r.js</a>进行代码优化.</p>

<h2>构建和部署</h2>

<p>任何web应用工程都需要构建和部署, 一个自动化的构建和部署脚本能让编程人员更加专注于应用本身, 而不被繁琐的流程所困扰.
自动化的构建和部署是一个web前端项目最基本的要求, 当项目开始的时候, 项目组最好能在头两个迭代周期就完成自动化的构建和部署脚本的开发.</p>

<p>目前使用比较多的构建工具有:</p>

<ul>
<li><a href="https://github.com/moxiecode/js-build-tools">js-build-tools</a></li>
<li><a href="https://github.com/jcoglan/jake/">jake</a></li>
<li>CoffeeScript自带的<a href="http://coffeescript.org/#cake">cake</a></li>
<li>make</li>
<li><a href="https://github.com/cowboy/grunt">grunt</a></li>
</ul>


<p>我个人比较倾向于<a href="https://github.com/cowboy/grunt">grunt</a>, 如果工程中用了<a href="http://requirejs.org/">RequireJS</a>,
<a href="https://github.com/backbone-boilerplate/grunt-bbb">bbb</a>(grunt扩展)是更好的选择.</p>

<p>在<a href="https://github.com/xiaocong/xiaocong.github.com/tree/master/examples/coffee-bbb-amd-backbone-rest-contacts">网络地址本例子工程</a>中,
我使用<code>grunt/bbb</code>开发了构建和部署脚本, 可以完成:</p>

<ul>
<li>文件的复制和清除</li>
<li>CoffeeScript的编译</li>
<li>JSHint</li>
<li>Minification &amp; Concatenation</li>
<li>在Phantom环境下运行Jasmine单元测试</li>
<li>Debug/Release Web服务器</li>
</ul>


<p>感兴趣的人可以去看看上述例子工程的<a href="https://github.com/xiaocong/xiaocong.github.com/tree/master/examples/coffee-bbb-amd-backbone-rest-contacts/grunt.js">grunt.js</a>配置文件,
也可以将这个例子工程作为web前端项目的模板.</p>

<p><strong>下面的几点感触和具体的技术细节无关, 但是我个人觉得, 对于每个想以编程作为自己职业规划的程序员来说, 这几点尤其重要.</strong></p>

<h2>了解业界的技术发展动态</h2>

<p>软件技术发展很快, 对于热爱技术的程序员来说, 必须经常更新自己的知识, 才能保证自己不会落伍.
因此, 每天都需要花一定时间去阅读, 了解行业最新的技术发展动态.</p>

<p>我的习惯是用Google Reader订阅几个经常更新的前端技术相关的RSS:</p>

<ul>
<li><a href="http://addyosmani.com/blog/">Addy Osmani&rsquo;s Blog</a></li>
<li><a href="http://dailyjs.com/">DailyJS</a></li>
<li><a href="http://www.mhtml5.com/">HTML5研究小组</a></li>
</ul>


<p>另外, 有些邮件周报也很不错:</p>

<ul>
<li><a href="http://javascriptweekly.com/">JavaScript Weekly</a></li>
<li><a href="http://html5weekly.com/">HTML5 Weekly</a></li>
</ul>


<h2>多阅读开源代码, 最好参与感兴趣的开源项目</h2>

<p><a href="http://github.com/">GitHub</a>是一个非常有用的站点, 在上面能看到那些大牛们是怎么讨论问题, 如何思考问题, 以及如何实现或者修正的.
阅读开源项目的文档能了解概要, 如果需要了解细节, 最有效的方式是阅读代码, 特别是看针对问题的提交记录.</p>

<h2>善于利用互联网工具</h2>

<h3>遇到问题的时候, 要知道如何去寻找问题的答案</h3>

<p><a href="http://stackoverflow.com/">StackOverflow</a>是一个非常有名的编程问答站点, 我所遇到的大部分编程问题都能在上面找到答案,
即便没有答案, 也能找到其他人对这个问题的考虑. 另外, 别忘了强大的<a href="http://www.google.com/">Google Search</a>. 如果Google被墙, 可以考虑用<a href="http://www.bing.com/">Bing</a>.
我不喜欢<a href="http://www.baidu.com/">百度</a>, 因为其搜索的命中率太低了.</p>

<h3>善于使用云端的工具</h3>

<p>选择合适的工具对于软件项目来说, 可以极大地提高工作效率, 起到事半功倍的效果. 好的商业软件大多需要支付巨额的费用, 并且搞不好还水土不服.
为了控制成本, 可以多尝试尝试云端的工具. 在<a href="http://www.zhihu.com/question/20114578">知乎</a>上有关于这些工具的讨论, 大家有兴趣可以去看看别人怎么做的.</p>

<h3>多参与技术社区活动, 学会分享</h3>

<p>多参加技术社区的活动, 包括线上的技术解答, 以及线下的技术讲座等. 分享越多, 获得也就越多.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Requirejs/Backbone/Jasmine前端项目和持续继承]]></title>
    <link href="http://xiaocong.github.io/blog/2012/07/20/integrate-requirejs-slash-backbone-slash-jasmine-front-end-project-with-ci-using-bbb-slash-gruntjs/"/>
    <updated>2012-07-20T11:03:00+08:00</updated>
    <id>http://xiaocong.github.io/blog/2012/07/20/integrate-requirejs-slash-backbone-slash-jasmine-front-end-project-with-ci-using-bbb-slash-gruntjs</id>
    <content type="html"><![CDATA[<p><a href="http://xiaocong.github.com/examples/coffee-bbb-amd-backbone-rest-contacts/dist/release/">Contact</a>(<a href="https://github.com/xiaocong/xiaocong.github.com/tree/master/examples/coffee-bbb-amd-backbone-rest-contacts">源代码</a>)示例项目使用了<a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a>作为项目构建工具,
作为<a href="https://github.com/cowboy/grunt" title="task-based command line build tool for JavaScript projects">gruntjs</a>的扩展, <a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a>能很方便地完成:</p>

<ul>
<li>Coffeescript的编译</li>
<li>文件的清除和复制</li>
<li>源代码lint</li>
<li>编译LESS</li>
<li>优化requirejs模块</li>
<li>js/css文件的合并和优化</li>
<li>文件的压缩, 打包</li>
<li>内置调试http服务器</li>
</ul>


<p>并且项目中还使用<a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a>进行<a href="http://pivotal.github.com/jasmine/">jasmine</a>单元测试代码的编译. 所有的操作都可以通过定义<a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a>任务并以命令行方式进行运行, 唯一的一个例外是<a href="http://pivotal.github.com/jasmine/">jasmine</a>测试执行需要启动浏览器执行.
如果要在项目中实施持续集成, 就必须不能依赖浏览器而以命令行方式执行测试.</p>

<p>曾经尝试过<a href="http://www.envjs.com/">envjs</a>, 但在当前的实现中, <a href="http://www.envjs.com/">envjs</a>还不能顺利运行<a href="http://requirejs.org/">requirejs</a>的异步模块加载(<a href="https://github.com/envjs/env-js/issues/7">issue</a>).
<a href="http://phantomjs.org/">Phantomjs</a>是另外一种方案, 它可以很顺利地集成<a href="http://pivotal.github.com/jasmine/">jasmine</a>以及<a href="http://requirejs.org/">requirejs</a>, 但是如果需要集成得很好, 必须得实现一个<a href="http://pivotal.github.com/jasmine/">jasmine</a>的<code>reporter</code>用来和<a href="http://phantomjs.org/">Phantomjs</a>进行通讯,
并且还得实现一个<a href="https://github.com/cowboy/grunt" title="task-based command line build tool for JavaScript projects">gruntjs</a>任务插件, 用来调用<a href="http://phantomjs.org/">Phantomjs</a>执行测试, 以及生成测试报告. 这个工作量不大, 我也曾经完成了一个最简单的<a href="https://github.com/cowboy/grunt" title="task-based command line build tool for JavaScript projects">gruntjs</a>任务来调用<a href="http://phantomjs.org/">Phantomjs</a>. 正在想着怎样进行重构的时候,
突然发现最新的<a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a>已经悄然导入了<a href="https://github.com/creynders/grunt-jasmine-task">grunt-jasmine-task</a>, 一个利用<a href="http://phantomjs.org/">Phantomjs</a>执行<a href="http://pivotal.github.com/jasmine/">jasmine</a>测试的<a href="https://github.com/cowboy/grunt" title="task-based command line build tool for JavaScript projects">gruntjs</a>任务插件.</p>

<p>Ok, 那一切就简单了. 现在仅仅需要修改<code>grunt.js</code>配置文件来定义项目的<code>jasmine</code>任务. 当然, 之前必须安装<a href="http://phantomjs.org/">Phantomjs</a>(<a href="https://github.com/cowboy/grunt" title="task-based command line build tool for JavaScript projects">gruntjs</a>网站上有关于如何安装的<a href="https://github.com/cowboy/grunt/blob/master/docs/faq.md#why-does-grunt-complain-that-phantomjs-isnt-installed">faq</a>).
``` javascript
  grunt.initConfig({</p>

<pre><code>// jasmine task is to run specs using phantom, before running it, you must
// make sure you have installed phantom following instruction on
// https://github.com/cowboy/grunt/blob/master/docs/faq.md#why-does-grunt-complain-that-phantomjs-isnt-installed
jasmine: {
  all: {
    src:['http://localhost:8000/tests/SpecRunner.html'],
    timeout: 300000 //in milliseconds
  }
}
</code></pre>

<p>  });</p>

<p><code>
启动`http`服务:
</code> bash
$ ./node_modules/bbb/bin/bbb server
Running &ldquo;server&rdquo; task
Listening on <a href="http://127.0.0.1:8000">http://127.0.0.1:8000</a></p>

<p><code>
然后在另一个终端运行`jasmine`任务:
</code> bash
$ ./node_modules/bbb/bin/bbb jasmine
Running &ldquo;jasmine:all&rdquo; (jasmine) task
Running specs for SpecRunner.html
&hellip;&hellip;&hellip;&hellip;.</p>

<blockquote><blockquote><p>31 assertions passed in 13 specs (1451ms)</p></blockquote></blockquote>

<p>Done, without errors.</p>

<p>```</p>

<!--more-->


<p>在CI系统中, 一种可行的做法是使用<code>shell</code>脚本或者<code>Makefile</code>, 先启动<code>http</code>服务, 然后异步执行测试. 这是一个可行的方案, 但是<code>grunt.js</code>本身就是一个命令行工具, 为什么还要用<code>shell</code>或者<code>make</code>了?</p>

<p><code>grunt.js</code>支持<code>alias task</code>, 我们可以这样定义一个任务别名:
<code>javascript
grunt.registerTask('test', 'default server jasmine');
</code>
执行<code>test</code>任务等价于按照顺序执行<code>default</code>, <code>server</code>, <code>jasmine</code>任务. 我们希望这样能工作, 可惜的是, <code>bbb</code>的<code>server</code>任务是阻塞式的, 不会退出,
也就是说, 在它后面的<code>jasmine</code>任务永远不会被执行.</p>

<p>我们希望执行一个<code>server</code>任务, 它能异步启动一个非阻塞的<code>http</code>服务, 后面的任务可以使用这个服务, 并且当<code>grunt</code>进程退出的时候, 该<code>http</code>服务能自动退出.
下面代码是用<code>node</code>的<code>connect</code>实现的满足这个要求的<code>staticserver</code>任务:
``` javascript staticserver.js
/<em>
 * grunt
 * <a href="https://github.com/cowboy/grunt">https://github.com/cowboy/grunt</a>
 *
 * Copyright &copy; 2012 &ldquo;Cowboy&rdquo; Ben Alman
 * Licensed under the MIT license.
 * <a href="http://benalman.com/about/license/">http://benalman.com/about/license/</a>
 </em>/</p>

<p>module.exports = function(grunt) {</p>

<p>  // Nodejs libs.
  var path = require(&lsquo;path&rsquo;);</p>

<p>  // External libs.
  var connect = require(&lsquo;connect&rsquo;);</p>

<p>  // ==========================================================================
  // TASKS
  // ==========================================================================</p>

<p>  grunt.registerTask(&lsquo;staticserver&rsquo;, &lsquo;Start a static web server.&rsquo;, function() {</p>

<pre><code>// Get values from config, or use defaults.
var port = grunt.config('server.port') || 8000;
var base = path.resolve(grunt.config('server.base') || '.');

var middleware = [
  // Serve static files.
  connect.static(base),
  // Make empty directories browsable. (overkill?)
  connect.directory(base)
];

// If --debug was specified, enable logging.
if (grunt.option('debug')) {
  connect.logger.format('grunt', ('[D] server :method :url :status ' +
    ':res[content-length] - :response-time ms').magenta);
  middleware.unshift(connect.logger('grunt'));
}

// Start server.
grunt.log.writeln('Starting static web server on port ' + port + '.');
connect.apply(null, middleware).listen(port);
</code></pre>

<p>  });</p>

<p>};</p>

<p><code>``
假如你看过[gruntjs][]的代码, 你应当能看出来, 这其实就是[gruntjs][]自带的</code>server<code>任务, 只是为了避免和</code>bbb<code>的</code>server<code>任务命名冲突, 这里将任务注册的名称从</code>server<code>换成了</code>staticserver`.</p>

<p>将<code>staticserver.js</code>文件和其他<code>gruntjs</code> <code>task</code>文件一样存放在<code>&lt;工程目录&gt;/tasks</code>目录下, 确保这个任务能正确加载. 然后, 如下注册一个<code>alias task</code>命名为<code>test</code>:
``` javascript
  // Register test task, which will compile app and run the server and then do test.
  // Here we use &lsquo;staticserver&rsquo; task (pure grunt static server) for testing.
  grunt.registerTask(&lsquo;test&rsquo;, &lsquo;default staticserver jasmine&rsquo;);</p>

<p><code>
运行这个`test`任务就能到下面的输出:
</code>
$ ./node_modules/bbb/bin/bbb test
Running &ldquo;clean:0&rdquo; (clean) task
Removing: app
Removing: dist/debug
Removing: dist/release
Removing: tests/js</p>

<p>Running &ldquo;clean:1&rdquo; (clean) task
Removing: app
Removing: dist/debug
Removing: dist/release
Removing: tests/js</p>

<p>Running &ldquo;clean:2&rdquo; (clean) task
Removing: app
Removing: dist/debug
Removing: dist/release
Removing: tests/js</p>

<p>Running &ldquo;clean:3&rdquo; (clean) task
Removing: app
Removing: dist/debug
Removing: dist/release
Removing: tests/js</p>

<p>Running &ldquo;coffee:app&rdquo; (coffee) task</p>

<p>Running &ldquo;lint:beforeconcat&rdquo; (lint) task
Lint free.</p>

<p>Running &ldquo;coffee:spec&rdquo; (coffee) task</p>

<p>Running &ldquo;staticserver&rdquo; task
Starting static web server on port 8000.</p>

<p>Running &ldquo;jasmine:all&rdquo; (jasmine) task
Running specs for SpecRunner.html
&hellip;&hellip;&hellip;&hellip;.</p>

<blockquote><blockquote><p>31 assertions passed in 13 specs (2256ms)</p></blockquote></blockquote>

<p>Done, without errors.</p>

<p>```</p>

<h2>参考</h2>

<ul>
<li><a href="https://github.com/xiaocong/xiaocong.github.com/tree/master/examples/coffee-bbb-amd-backbone-rest-contacts">示例程序源代码</a></li>
<li><a href="https://github.com/backbone-boilerplate/grunt-bbb" title="Backbone Boilerplate framework tool.">bbb</a></li>
<li><a href="https://github.com/cowboy/grunt" title="task-based command line build tool for JavaScript projects">gruntjs</a></li>
<li><a href="http://phantomjs.org/">Phantomjs</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用jasmine+sinon测试backbone+requirejs项目]]></title>
    <link href="http://xiaocong.github.io/blog/2012/07/06/testing-backbone-and-requirejs-with-jasmine/"/>
    <updated>2012-07-06T00:32:00+08:00</updated>
    <id>http://xiaocong.github.io/blog/2012/07/06/testing-backbone-and-requirejs-with-jasmine</id>
    <content type="html"><![CDATA[<p>我们必须为自己的代码写自动测试代码, 并且需要持续地对自己的代码进行回归测试, 因为:</p>

<ul>
<li>项目成员对模块间接口的理解必须一致, 测试代码是最好的文档.</li>
<li>谁都没十足的把握保证自己的修改不影响别人的代码.</li>
<li>没有快速而充分的测试作为保障, 就很难提倡快速重构.</li>
<li>让代码成为资产, 而不是债务, 减少代码的维护成本.</li>
<li>每个人都必须为自己的代码负责.</li>
</ul>


<p>那么基于<a href="http://backbonejs.com/" title="Backbone.js">backbone</a>+<a href="http://requirejs.org/" title="Require.js">requirejs</a>的前端项目应当如何实施测试?</p>

<p>当前已经有很多非常优秀的javascript测试框架, 包括<a href="http://pivotal.github.com/jasmine/">jasmine</a>,
<a href="http://docs.jquery.com/QUnit">QUnit</a>, <a href="http://visionmedia.github.com/mocha/">mocha</a>.
<a href="http://backbonejs.com/" title="Backbone.js">backbone</a>和<a href="http://requirejs.org/" title="Require.js">requirejs</a>的前端项目可以使用上述任何一种测试框架. 技术经理可以根据团队成员的技术背景, 喜好来决定选择哪一种测试框架.</p>

<p>下面就以<a href="/examples/coffee-bbb-amd-backbone-rest-contacts/index.html">Contacts</a>应用为例,
简单demo如何在项目中实现基于<a href="http://pivotal.github.com/jasmine/">jasmine</a>+<a href="http://sinonjs.org/" title="sinon.js">sinon</a>的测试用例.</p>

<ul>
<li><a href="https://github.com/xiaocong/xiaocong.github.com/tree/master/examples/coffee-bbb-amd-backbone-rest-contacts">源码</a></li>
<li><a href="/examples/coffee-bbb-amd-backbone-rest-contacts/tests/SpecRunner.html">测试执行demo</a></li>
</ul>


<h2>工程的目录结构</h2>

<p>``` bash
|-coffee                # web应用coffeescript源代码
|-app                   # coffee编译之后的web应用js文件
|-dist
   |-debug              # concat所有js文件到一个js文件, 但未作minize
   |-release            # concat所有js文件到一个js文件, 并且minize
|-assets                # jquery/requirejs/underscore/backbone等库文件
|-tests
   |-coffee             # 测试程序的coffeescript源代码</p>

<pre><code>  |-config.coffee   # requirejs配置文件
  |-runner.coffee   # 按照requirejs模块定义规范定义的jasmine测试执行模块
</code></pre>

<p>   |-js                 # coffee编译之后的测试程序js文件
   |-lib                # jasmine/sinon等测试用库文件
   |-SpecRunner.html    # 测试html文件, 用来执行broqser端测试代码
|-index.html            # app html文件
|-favicon.ico
|-grunt.js              # grunt任务配置文件
```</p>

<h2>按照<a href="http://requirejs.org/" title="Require.js">requirejs</a>的模块定义方式定义<em>测试模块</em></h2>

<p>由于<em>被测模块</em>是由<a href="http://requirejs.org/" title="Require.js">requirejs</a>进行加载的, 因此, 我们也可以遵循<a href="http://requirejs.org/" title="Require.js">requirejs</a>的模块定义方式定义<em>测试模块</em>, 确保<em>被测模块</em>在<em>测试模块</em>前加载完成:
``` coffeescript model_spec.coffee
define [use!underscore', &lsquo;use!backbone&rsquo;, &lsquo;model/under/test&rsquo;], (_, Backbone, model) &ndash;>
  describe &ldquo;suite description&hellip;&rdquo;, &ndash;></p>

<pre><code>it "spec description...", -&gt;
  # test code here ...
</code></pre>

<p><code>``
下面是测试用例的代码(</code>collection<code>,</code>model<code>,</code>view`各实现了一个模块的测试, 仅供demo):</p>

<ul>
<li><a href="/examples/coffee-bbb-amd-backbone-rest-contacts/tests/coffee/spec/collections/contacts.coffee">Collection测试Dmeo</a></li>
<li><a href="/examples/coffee-bbb-amd-backbone-rest-contacts/tests/coffee/spec/models/contact.coffee">Model测试Demo</a></li>
<li><a href="/examples/coffee-bbb-amd-backbone-rest-contacts/tests/coffee/spec/views/contactitem.coffee">View测试Demo</a></li>
</ul>


<!--more-->


<h2>加载<em>测试模块</em>, 定义测试<code>runner</code></h2>

<p>通过定义模块依赖, 确保在执行<code>runner</code>方法前加载所有的<em>测试模块</em>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>SpecRunner  (runner.coffee)</span> <a href='/examples/coffee-bbb-amd-backbone-rest-contacts/tests/coffee/runner.coffee'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="c1"># we should add all specs here to make sure all specs are loaded before execution.</span>
</span><span class='line'><span class="nx">define</span> <span class="p">[</span><span class="s">&quot;spec/models/contact&quot;</span>
</span><span class='line'>        <span class="s">&quot;spec/collections/contacts&quot;</span>
</span><span class='line'>        <span class="s">&quot;spec/views/contactitem&quot;</span><span class="p">],</span> <span class="nf">-&gt;</span>
</span><span class='line'>  <span class="nv">runner = </span><span class="nf">-&gt;</span>
</span><span class='line'>    <span class="nv">jasmineEnv = </span><span class="nx">jasmine</span><span class="p">.</span><span class="nx">getEnv</span><span class="p">()</span>
</span><span class='line'>    <span class="nv">jasmineEnv.updateInterval = </span><span class="mi">1000</span>
</span><span class='line'>    <span class="nv">trivialReporter = </span><span class="k">new</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">TrivialReporter</span><span class="p">()</span>
</span><span class='line'>    <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">addReporter</span> <span class="nx">trivialReporter</span>
</span><span class='line'>    <span class="nv">jasmineEnv.specFilter = </span><span class="nf">(spec) -&gt;</span>
</span><span class='line'>      <span class="nx">trivialReporter</span><span class="p">.</span><span class="nx">specFilter</span> <span class="nx">spec</span>
</span><span class='line'>    <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">execute</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>定义<a href="http://requirejs.org/" title="Require.js">requirejs</a>的配置文件, 执行测试<code>runner</code></h2>

<p>由于我们希望通过一个配置文件同时加载<em>被测模块</em>和<em>测试模块</em>, 因此这里<code>require.config</code>的<code>baseUrl</code>项必须与web应用的该值保持一致.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>require.config  (config.coffee)</span> <a href='/examples/coffee-bbb-amd-backbone-rest-contacts/tests/coffee/config.coffee'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">require</span><span class="p">.</span><span class="nx">config</span>
</span><span class='line'>  <span class="nv">baseUrl: </span><span class="s">&quot;../app&quot;</span>
</span><span class='line'>  <span class="nv">paths:</span>
</span><span class='line'>    <span class="nv">libs: </span><span class="s">&quot;../assets/js&quot;</span>
</span><span class='line'>    <span class="nv">jquery: </span><span class="s">&#39;../assets/js/jquery/1.7.2/jquery&#39;</span>
</span><span class='line'>    <span class="nv">underscore: </span><span class="s">&#39;../assets/js/underscore/1.3.2/underscore&#39;</span>
</span><span class='line'>    <span class="nv">backbone: </span><span class="s">&#39;../assets/js/backbone/0.9.2/backbone&#39;</span>
</span><span class='line'>    <span class="nv">text: </span><span class="s">&#39;../assets/js/require/plugins/text&#39;</span>
</span><span class='line'>    <span class="nv">templates: </span><span class="s">&#39;../assets/templates&#39;</span>
</span><span class='line'>    <span class="nv">spec: </span><span class="s">&quot;../tests/js/spec&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">shim:</span>
</span><span class='line'>    <span class="s">&#39;backbone&#39;</span><span class="o">:</span>
</span><span class='line'>      <span class="nv">deps: </span><span class="p">[</span><span class="s">&#39;underscore&#39;</span><span class="p">,</span> <span class="s">&#39;jquery&#39;</span><span class="p">],</span>
</span><span class='line'>      <span class="nv">exports: </span><span class="s">&#39;Backbone&#39;</span>
</span><span class='line'>
</span><span class='line'>    <span class="s">&#39;underscore&#39;</span><span class="o">:</span>
</span><span class='line'>      <span class="nv">exports: </span><span class="s">&#39;_&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="nx">require</span> <span class="p">[</span><span class="s">&quot;../tests/js/runner&quot;</span><span class="p">],</span> <span class="nf">(runner) -&gt;</span>
</span><span class='line'>  <span class="nx">runner</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>定义<code>SpecRunner.html</code>, 用来在浏览器端执行策测试代码</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>SpecRunner.html  (SpecRunner.html)</span> <a href='/examples/coffee-bbb-amd-backbone-rest-contacts/tests/SpecRunner.html'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="o">&lt;!</span><span class="nx">DOCTYPE</span> <span class="nx">HTML</span> <span class="nx">PUBLIC</span> <span class="s">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>
</span><span class='line'>  <span class="s">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="nx">html</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="nx">head</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">title</span><span class="o">&gt;</span><span class="nx">Jasmine</span> <span class="nx">Spec</span> <span class="nx">Runner</span><span class="o">&lt;/</span><span class="nx">title</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">link</span> <span class="nx">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="nx">type</span><span class="o">=</span><span class="s">&quot;text/css&quot;</span> <span class="nx">href</span><span class="o">=</span><span class="s">&quot;lib/jasmine.css&quot;</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span> <span class="nx">src</span><span class="o">=</span><span class="s">&quot;lib/jasmine.js&quot;</span><span class="o">&gt;&lt;/</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span> <span class="nx">src</span><span class="o">=</span><span class="s">&quot;lib/jasmine-html.js&quot;</span><span class="o">&gt;&lt;/</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span> <span class="nx">src</span><span class="o">=</span><span class="s">&quot;lib/sinon.js&quot;</span><span class="o">&gt;&lt;/</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">data</span><span class="o">-</span><span class="nx">main</span><span class="o">=</span><span class="s">&quot;js/config&quot;</span> <span class="nx">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span> <span class="nx">src</span><span class="o">=</span><span class="s">&quot;../assets/js/require/require.js&quot;</span><span class="o">&gt;&lt;/</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="nx">head</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="nx">body</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="nx">html</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>下面是<a href="/examples/coffee-bbb-amd-backbone-rest-contacts/tests/SpecRunner.html">测试执行</a>的结果:</p>

<iframe src="http://xiaocong.github.io/examples/coffee-bbb-amd-backbone-rest-contacts/tests/SpecRunner.html" width="100%" scrolling="no"></iframe>


<h2>遗留问题</h2>

<ul>
<li>由于<em>被测模块</em>的加载是由<a href="http://requirejs.org/" title="Require.js">requirejs</a>完成的, 那么如何在加载时mock<em>被测模块</em>的依赖模块?</li>
<li>如何和CI系统集成, 提供命令行方式的浏览器环境进行测试? 尝试过<a href="http://www.envjs.com/">envjs</a>, 但<a href="http://requirejs.org/" title="Require.js">requirejs</a>总在加载模块时出错, 还没能进一步研究出错细节.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone.sync和资源的CRUD]]></title>
    <link href="http://xiaocong.github.io/blog/2012/06/26/backbone-dot-sync-and-crud/"/>
    <updated>2012-06-26T01:33:00+08:00</updated>
    <id>http://xiaocong.github.io/blog/2012/06/26/backbone-dot-sync-and-crud</id>
    <content type="html"><![CDATA[<p><blockquote><p>Backbone.sync是Backbone用来和服务器进行数据交换的方法. 每当Collection或者Model的数据发生变化, Backbone就会调用Backbone.sync进行数据的CRUD操作, 这个同步方法的缺省实现是使用(jQuery/Zepto).ajax向服务器发送RESTful JSON请求, 并返回一个jqXHR. 你可以通过重载这个方法来定义不同的持续化策略, 例如WebSocket, XML, 或者本地存储.</p><footer><strong>Backbone <a href="http://documentcloud.github.com/backbone/#Sync">http://documentcloud.github.com/backbone/#Sync</a> Backbone.sync</strong></footer></blockquote></p>

<p>Backbone.sync的函数定义是<code>function(method, model, [options])</code>:</p>

<ul>
<li><strong>medhod</strong>: CRUD名称, 可以是<code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>.</li>
<li><strong>model</strong>: 需要保存的model, 可以是Backbone.Model或者Backbone.Collection.</li>
<li><strong>options</strong>: 所有jQuery请求选项, 包括success和error回掉函数.</li>
</ul>


<p>Backbone.sync方法的缺省实现是通过标准的RESTful风格的CRUD进行数据的操作. CRUD方法对应的REST接口分别是:</p>

<ul>
<li><strong>create</strong> &ndash;> <strong>POST</strong> <code>/collection</code></li>
<li><strong>read</strong> &ndash;> <strong>GET</strong> <code>/collection[/id]</code></li>
<li><strong>update</strong> &ndash;> <strong>PUT</strong> <code>/collection/id</code></li>
<li><strong>create</strong> &ndash;> <strong>DELETE</strong> <code>/collection/id</code></li>
</ul>


<p>你可以通过重载全局的Backbone.sync, 或者Collection/Model的sync方法来改变其缺省实现.</p>

<h2>localStorage方式实现Backbone.sync</h2>

<p>在<a href="http://xiaocong.github.com/examples/coffee-bbb-amd-backbone-contacts/index.html">地址本示例</a>中, 通过重载全局的Backbone.sync方法,
将Collection/Model的CRUD操作转化为localStorage的对象CRUD操作.</p>

<p>下面是Backbone.sync方法的定义(<a href="http://xiaocong.github.com/examples/coffee-bbb-amd-backbone-contacts/coffee/store.coffee">源码</a>),
首先获得传递进来的model对象或其集合对象的localStorage属性对象, 并将CRUD操作转化为localStorage属性对象的数据CRUD操作:
``` coffeescript
  Backbone.sync = (method, model, options) &ndash;></p>

<pre><code>store = model.localStorage or model.collection.localStorage

switch method
  when "read"
    resp = if model.id then store.find(model) else store.findAll()
  when "create"
    resp = store.create(model)
  when "update"
    resp = store.update(model)
  when "delete"
    resp = store.destroy(model)

if resp
  options.success resp
else
  options.error "Record not found"
</code></pre>

<p>```</p>

<!--more-->


<p>localStorage属性对象的类型定义如下, 数据最后是通过HTML本地存储方法<code>localStorage.setItem</code>进行持久化存储:
``` coffeescript
  class Store</p>

<pre><code>constructor: (@name) -&gt;
  store = localStorage.getItem(@name)
  @data = (store and JSON.parse(store)) or {}

save: -&gt;
  localStorage.setItem @name, JSON.stringify(@data)

create: (model) -&gt;
  model.id = model.attributes.id = guid() unless model.id
  @data[model.id] = model
  @save()
  model

update: (model) -&gt;
  @data[model.id] = model
  @save()
  model

find: (model) -&gt;
  @data[model.id]

findAll: -&gt;
  _.values @data

destroy: (model) -&gt;
  delete @data[model.id]
  @save()
  model
</code></pre>

<p><code>``
在定义Collection对象的时候, 需要定义其localStorage属性为上面定义的</code>Store`类型:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (contacts.coffee)</span> <a href='/examples/coffee-bbb-amd-backbone-contacts/coffee/collections/contacts.coffee'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">define</span> <span class="p">[</span><span class="s">&#39;use!underscore&#39;</span><span class="p">,</span> <span class="s">&#39;use!backbone&#39;</span><span class="p">,</span> <span class="s">&#39;models/contact&#39;</span><span class="p">,</span> <span class="s">&#39;store&#39;</span><span class="p">],</span> <span class="nf">(_, Backbone, Contact, Store) -&gt;</span>
</span><span class='line'>  <span class="nv">Contacts = </span><span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span>
</span><span class='line'>    <span class="nv">model: </span><span class="nx">Contact</span>
</span><span class='line'>    <span class="nv">localStorage: </span><span class="k">new</span> <span class="nx">Store</span><span class="p">(</span><span class="s">&#39;my-contacts&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="k">new</span> <span class="nx">Contacts</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>Backbone.sync标准CRUD REST接口</h2>

<p>如果采用标准的CRUD REST接口进行数据交换, 那就不用重载Backbone.sync方法, 只需要定义Collection的url属性(字符串或者方法)即可.
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (contacts.coffee)</span> <a href='/examples/coffee-bbb-amd-backbone-rest-contacts/coffee/collections/contacts.coffee'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">define</span> <span class="p">[</span><span class="s">&#39;underscore&#39;</span><span class="p">,</span> <span class="s">&#39;backbone&#39;</span><span class="p">,</span> <span class="s">&#39;models/contact&#39;</span><span class="p">],</span> <span class="nf">(_, Backbone, Contact) -&gt;</span>
</span><span class='line'>  <span class="nv">Contacts = </span><span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span>
</span><span class='line'>    <span class="nv">model: </span><span class="nx">Contact</span>
</span><span class='line'>    <span class="nv">url: </span><span class="s">&#39;http://xiaocong.herokuapp.com/contacts/&#39;</span>
</span><span class='line'>    <span class="nv">parse: </span><span class="nf">(resp) -&gt;</span>
</span><span class='line'>      <span class="nx">resp</span><span class="p">.</span><span class="nx">results</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="k">new</span> <span class="nx">Contacts</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中<code>http://xiaocong.herokuapp.com/contacts/</code>实现了标准的CRUD REST接口:</p>

<ul>
<li><strong>POST</strong> /contacts 生成一个新的地址本记录, 并返回带有新生成的id的地址本数据, 供客户端更新model的id.</li>
<li><strong>GET</strong> /contacts 获取所有地址本数据, 由于Collection对象需要的集合数组在返回的JSON字符串的<code>results</code>属性中, 因此需要通过<code>parse</code>方法转换一下返回的结果.</li>
<li><strong>GET</strong> /contacts/id 获取指定id的地址本数据.</li>
<li><strong>PUT</strong> /contacts/id 更新指定id的地址本数据.</li>
<li><strong>DELETE</strong> /contacts/id 删除指定id的地址本数据</li>
</ul>


<p><a href="/examples/coffee-bbb-amd-backbone-rest-contacts/index.html">使用该CRUD REST接口的演示</a>.</p>

<p>下面是托管在<a href="http://www.heroku.com">heroku</a>上的该REST接口的python源代码:</p>

<ul>
<li>使用<a href="http://bottlepy.org/docs/dev/">bottle</a>微型web框架实现HTTP路由管理</li>
<li>使用<a href="http://www.sqlalchemy.org/">sqlalchemy</a>实现数据库的持续化存储</li>
<li>使用<a href="http://www.gevent.org/">gevent</a>实现HTTP并发服务</li>
<li>通过<code>Access-Control-Allow-Origin</code>实现跨域调用</li>
</ul>


<p>``` python app.py
from gevent import monkey; monkey.patch_all()</p>

<p>from bottle import Bottle, route, get, post, put, delete, request, response, run, static_file, HTTPError
from bottle.ext import sqlalchemy
from sqlalchemy import create_engine, Column, Integer, Sequence, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError</p>

<p>import os</p>

<p>app = Bottle()</p>

<p>@app.route(&ldquo;/&rdquo;)
def hello():</p>

<pre><code>return "APIs for demo!"
</code></pre>

<p>Base = declarative_base()
engine = create_engine(os.environ[&ldquo;SHARED_DATABASE_URL&rdquo;], echo=True)
create_session = sessionmaker(bind=engine)</p>

<p>class Contact(Base):</p>

<pre><code>__tablename__ = "contact"
id = Column(Integer, Sequence('contact_id_seq'), primary_key=True)
name = Column(String(50))
email = Column(String(64))

def __init__(self, name, email):
    self.name = name
    self.email = email

def __repr__(self):
    return "&lt;Contact('%d', '%s', '%s')&gt;" % (self.id, self.name, self.email)
</code></pre>

<p>contactsApp = Bottle()</p>

<p>@contactsApp.hook(&ldquo;after_request&rdquo;)
def crossDomianHook():</p>

<pre><code>response.headers["Access-Control-Allow-Origin"] = "*"
</code></pre>

<p>@contactsApp.route(path=&ldquo;/&rdquo;, method=&ldquo;OPTIONS&rdquo;)
def options1(*args):</p>

<pre><code>return options(*args)
</code></pre>

<p>@contactsApp.route(path=&ldquo;/:id&rdquo;, method=&ldquo;OPTIONS&rdquo;)
def options2(id, *args):</p>

<pre><code>return options(*args)
</code></pre>

<p>def options(*args):</p>

<pre><code>response.headers["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE"
if request.headers.get("Access-Control-Request-Headers"):
    response.headers["Access-Control-Allow-Headers"] = request.headers["Access-Control-Request-Headers"]
</code></pre>

<p>@contactsApp.post(&ldquo;/&rdquo;)
def createContact(db):</p>

<pre><code>'''Create contact'''
contact = Contact(name=request.json["name"], email=request.json["email"])
db.add(contact)
db.commit()
return {"id": contact.id, "name": contact.name, "email": contact.email}
</code></pre>

<p>@contactsApp.get(&ldquo;/&rdquo;)
def getAllContacts(db):</p>

<pre><code>'''Retrieve all contacts'''
contacts = db.query(Contact)
return {"results": [{"id":contact.id, "name":contact.name, "email":contact.email} for contact in contacts]}
</code></pre>

<p>@contactsApp.get(&ldquo;/:id&rdquo;)
def getContact(id, db):</p>

<pre><code>'''Retrieve specified contact with id'''
contact = db.query(Contact).filter_by(id=id).first()
if contact:
    return {"id": contact.id, "name": contact.name, "email": contact.email}
raise HTTPError(404, "Contact not found.")
</code></pre>

<p>@contactsApp.put(&ldquo;/:id&rdquo;)
def updateContact(id, db):</p>

<pre><code>'''Update contact'''
session = create_session()
try:
    session.query(Contact).filter_by(id=id).update({"name": request.json["name"], "email": request.json["email"]})
    session.commit()
except SQLAlchemyError, e:
    session.rollback()
    raise HTTPError(500, "Database Error", e)
finally:
    session.close()
</code></pre>

<p>@contactsApp.delete(&ldquo;/:id&rdquo;)
def deleteContact(id, db):</p>

<pre><code>'''Delete contact'''
session = create_session()
try:
    contact = session.query(Contact).filter_by(id=id).first()
    session.delete(contact)
    session.commit()
except SQLAlchemyError, e:
    session.rollback()
    raise HTTPError(500, "Database Error", e)
finally:
    session.close()
</code></pre>

<p>sqlalchemyplugin = sqlalchemy.Plugin(engine, Base.metadata, create=True)
contactsApp.install(sqlalchemyplugin)
app.mount(&ldquo;/contacts&rdquo;, contactsApp)</p>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>port = int(os.environ.get("PORT", 5000))
run(app=app, server="gevent", host="0.0.0.0", port=port, reloader=True)
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
